import prelude;
import rand;
import util;
import operations;
import filter;

sample_sid {m}
  (sids :: gnss_signal_t[m])
  (out res :: gnss_signal_t[m])
  :: s32 := (
  indices :: s32[m];
  -- Choose sampling strategy here:
  --count := sample_k m (out indices);
  count := sample_uniform m (out indices);
  res[:count] <- sids[indices[:count]];
  count
);

make_measurement
  (s :: gnss_signal_t)
  :: measurement := (
  m :: measurement;
  m.pseudorange <- rand_normal ();
  m.carrier_phase <- rand_normal ();
  m.snr <- rand_normal () + 1;
  m.sat_id <- s;
  m
);

make_sat_sequence {num_sats}
  :: gnss_signal_t[num_sats] := (
  vec i in num_sats -> (
    s :: gnss_signal_t;
    s.sat <- i;
    s.code <- CODE_GPS_L1CA;
    s
  );
);

vec_not_nan {dim} (x :: double[dim]) :: bool := (
  for i in dim -> if isnan x[i] then return False;
  return True;
);

rand_n3 () :: double[3] := vec i in 3 -> rand_normal ();

test_add_drop
  (num_sats :: u32)
  (iterations :: u32) :: () := (
  state := make_filter_state ();
  sats := make_sat_sequence {num_sats};

  position := vec(0.0, 0, 0); -- TODO
  sat_positions := vec i in num_sats -> (10000+(5) * rand_n3 ());

  for iter in iterations -> (
    res :: gnss_signal_t[num_sats];
    count := sample_sid sats (out res);
    subset :: gnss_signal_t[count] := res[:count];
    printf "measurement sats: "; print_sats subset;
    measurements := vec i in count -> make_measurement subset[i];

    -- update
    update_ (inout state) measurements position sat_positions[:count];
    nl (); print_sat_state state;

    --printf "\nstate:\n"; print_vec state.x; nl ();
    --print_mat state.P; nl ();

    assert vec_not_nan state.x;
  );
  ()
);

sigtest (inout x :: gnss_signal_t) :: () := (
  x.sat <- 22;
  x.code <- 2;
);

main () :: int := (
  test_add_drop 10 22222; 0
);
