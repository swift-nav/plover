import prelude;

__C__ "#include <libswiftnav/linear_algebra.h>";
__C__ "#include <libswiftnav/constants.h>";
__C__ "#include <libswiftnav/signal.h>";
--__C__ "#include <libswiftnav/set.h>";

extern MAX_STATE_DIM :: int;
__C__ "#define MAX_STATE_DIM 22";

extern (
  GPS_L1_LAMBDA :: double;

  -- we don't use the fields; only call functions with gnss_signal_t parameters
  -- TODO make parser accept empty struct definition
  struct gnss_signal_t ( 
    sat :: u16;
    code :: u16; -- taken from enum values below
  );

  CODE_INVALID :: s32;
  CODE_GPS_L1CA :: s32;
  CODE_GPS_L2CM :: s32;
  CODE_SBAS_L1CA :: s32;
  CODE_COUNT :: s32;

  sid_to_code_index (x :: gnss_signal_t) :: u16;
  sid_is_equal(a :: gnss_signal_t) (b :: gnss_signal_t) :: bool;
);

struct measurement (
  pseudorange :: double;
  carrier_phase :: double;
  snr :: double;
  sat_id :: gnss_signal_t;
);

struct filter_state (
  num_sats :: int; -- must be at least 1!
  ref :: gnss_signal_t;
  sats :: gnss_signal_t[MAX_STATE_DIM] storing gnss_signal_t[num_sats-1];
  invalid :: bool;
  x :: double[MAX_STATE_DIM] storing double[num_sats+2];
  P :: double[MAX_STATE_DIM, MAX_STATE_DIM] storing double[num_sats+2, num_sats+2];

  sigma :: double;
);

-- TODO base type polymorphism
drop_i_1_double {d}
  (i :: u32)
  (v :: double[d])
  :: double[d-1] := (
  u :: double[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_1_s32 {d}
  (i :: u32)
  (v :: s32[d])
  :: s32[d-1] := (
  u :: s32[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_2 {d, n}
  (i :: u32)
  (v :: double[d,n])
  :: double[d-1,n] := (
  u :: double[d-1,n];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

find_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: s32 := (
  for i in dim -> (
    if sid_is_equal target sats[i] then
      return i
  );
  return -1;
);

contains_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: bool := find_sat target sats >= 0;

-- Print utils
nl () :: () := (printf "\n"; ());

print_sat (s :: gnss_signal_t) :: s32 := printf "%d, " s.sat;

print_sats {n} (s :: gnss_signal_t[n]) :: () := (
  for i in n -> (
    print_sat s[i];
  ); printf "\n"; ();
);

print_sat_state (s :: filter_state) :: () := (
  if s.invalid then (printf "state empty\n"; ())
  else (printf "("; print_sat s.ref; printf ")"; print_sats s.sats;);
);
